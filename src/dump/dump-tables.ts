import type { PGClient } from "../types.ts";

type ColumnDefinition = {
  name: string;
  type: string; // from pg_catalog.format_type
  nullable: boolean;
  default: string | null; // from pg_get_expr
  generated: "" | "s" | "a"; // empty string, 's' for STORED, 'a' for ALWAYS
  identity: "" | "a" | "d"; // empty string, 'a' for ALWAYS, 'd' for BY DEFAULT
};

export type TableDefinition = {
  schema_name: string;
  table_name: string;
  table_options: string[] | null;
  columns: ColumnDefinition[];
};

export async function extractTableDefinitions(
  db: PGClient,
): Promise<TableDefinition[]> {
  const tables = await db.sql<TableDefinition>`
    select 
      n.nspname as schema_name,
      c.relname as table_name,
      c.reloptions as table_options,
      -- columns
      (
        select json_agg(
          json_build_object(
            'name', a.attname,
            'type', pg_catalog.format_type(a.atttypid, a.atttypmod),
            'nullable', not a.attnotnull,
            'default', pg_get_expr(d.adbin, d.adrelid),
            'generated', a.attgenerated,
            'identity', a.attidentity
          )
          order by a.attnum
        )
        from pg_attribute a
        left join pg_attrdef d on d.adrelid = a.attrelid and d.adnum = a.attnum
        where a.attrelid = c.oid
        and a.attnum > 0  -- exclude system columns
        and not a.attisdropped  -- exclude dropped columns
      ) as columns
    from pg_class c
    join pg_namespace n on n.oid = c.relnamespace
    where c.relkind = 'r'  -- only regular tables
      and n.nspname not in ('pg_catalog', 'information_schema')
      and n.nspname not like 'pg_%'
    order by n.nspname, c.relname;
  `;

  return tables.rows;
}

export function serializeTableDefinitions(tables: TableDefinition[]): string {
  return tables
    .map((table) => {
      const columns = table.columns
        .map((column) => {
          const parts: string[] = [];

          // name and type
          parts.push(`${column.name} ${column.type}`);

          // nullable
          if (!column.nullable) {
            parts.push("not null");
          }

          // identity
          if (column.identity === "a") {
            parts.push("generated always as identity");
          } else if (column.identity === "d") {
            parts.push("generated by default as identity");
          }

          // generated
          if (column.generated === "a") {
            parts.push("generated always as");
          } else if (column.generated === "s") {
            parts.push("generated stored as");
          }

          // default
          if (column.default !== null) {
            parts.push(`default ${column.default}`);
          }

          return parts.join(" ");
        })
        .join(",\n  ");

      const options = table.table_options
        ? `\nwith (${table.table_options.join(", ")})`
        : "";

      return `create table ${table.schema_name}.${table.table_name} (\n  ${columns}\n)${options};`;
    })
    .join("\n\n");
}
