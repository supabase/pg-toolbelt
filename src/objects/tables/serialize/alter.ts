import type { DiffOperation } from "../../../diff/types.ts";
import type { TableDefinition } from "../types.ts";

type ColumnDefinition = TableDefinition["columns"][number];

export function serializeTableAlter(
  operation: DiffOperation<TableDefinition>,
): string {
  const { object, changes } = operation;
  const { schema_name, table_name } = object;

  if (!changes?.length) return "";

  const statements: string[] = [];

  // Handle column changes
  const columnChanges = changes.filter(
    (c): c is (typeof changes)[number] & { property: "columns" } =>
      c.property === "columns",
  );
  if (columnChanges.length > 0) {
    const oldColumns = columnChanges[0].oldValue as ColumnDefinition[];
    const newColumns = columnChanges[0].newValue as ColumnDefinition[];

    // Find dropped columns
    const droppedColumns = oldColumns
      .filter((old) => !newColumns.some((newCol) => newCol.name === old.name))
      .map((col) => col.name);

    // Find added columns
    const addedColumns = newColumns.filter(
      (newCol) => !oldColumns.some((old) => old.name === newCol.name),
    );

    // Find modified columns
    const modifiedColumns = newColumns.filter((newCol) => {
      const old = oldColumns.find((old) => old.name === newCol.name);
      return old && JSON.stringify(old) !== JSON.stringify(newCol);
    });

    // Generate ALTER statements
    droppedColumns.forEach((col) => {
      statements.push(
        `alter table ${schema_name}.${table_name} drop column ${col};`,
      );
    });

    addedColumns.forEach((col) => {
      const parts = [
        `alter table ${schema_name}.${table_name} add column ${col.name} ${col.type}`,
      ];
      if (!col.nullable) parts.push("not null");
      if (col.default !== null) parts.push(`default ${col.default}`);
      if (col.identity === "a") parts.push("generated always as identity");
      if (col.identity === "d") parts.push("generated by default as identity");
      if (col.generated === "a") parts.push("generated always as");
      if (col.generated === "s") parts.push("generated stored as");
      statements.push(parts.join(" ") + ";");
    });

    modifiedColumns.forEach((col) => {
      const old = oldColumns.find((old) => old.name === col.name);
      if (!old) return;

      // Handle type changes
      if (old.type !== col.type) {
        statements.push(
          `alter table ${schema_name}.${table_name} alter column ${col.name} type ${col.type};`,
        );
      }

      // Handle nullability changes
      if (old.nullable !== col.nullable) {
        statements.push(
          `alter table ${schema_name}.${table_name} alter column ${col.name} ${
            col.nullable ? "drop not null" : "set not null"
          };`,
        );
      }

      // Handle default changes
      if (JSON.stringify(old.default) !== JSON.stringify(col.default)) {
        if (col.default === null) {
          statements.push(
            `alter table ${schema_name}.${table_name} alter column ${col.name} drop default;`,
          );
        } else {
          statements.push(
            `alter table ${schema_name}.${table_name} alter column ${col.name} set default ${col.default};`,
          );
        }
      }

      // Handle identity changes
      if (old.identity !== col.identity) {
        if (col.identity === "") {
          statements.push(
            `alter table ${schema_name}.${table_name} alter column ${col.name} drop identity;`,
          );
        } else {
          statements.push(
            `alter table ${schema_name}.${table_name} alter column ${col.name} ${
              col.identity === "a"
                ? "set generated always"
                : "set generated by default"
            } as identity;`,
          );
        }
      }

      // Handle generated changes
      if (old.generated !== col.generated) {
        if (col.generated === "") {
          statements.push(
            `alter table ${schema_name}.${table_name} alter column ${col.name} drop generated;`,
          );
        } else {
          statements.push(
            `alter table ${schema_name}.${table_name} alter column ${col.name} ${
              col.generated === "a"
                ? "set generated always"
                : "set generated stored"
            } as;`,
          );
        }
      }
    });
  }

  // Handle table options changes
  const optionsChange = changes.find(
    (c): c is (typeof changes)[number] & { property: "table_options" } =>
      c.property === "table_options",
  );
  if (optionsChange) {
    const newOptions = optionsChange.newValue as string[] | null;
    if (newOptions === null) {
      statements.push(
        `alter table ${schema_name}.${table_name} reset (${(optionsChange.oldValue as string[]).join(", ")});`,
      );
    } else {
      statements.push(
        `alter table ${schema_name}.${table_name} set (${newOptions.join(", ")});`,
      );
    }
  }

  return statements.join("\n");
}
