{
	"meta": {
		"generatedAt": "2026-02-02T19:01:58.492Z",
		"tasksAnalyzed": 10,
		"totalTasks": 10,
		"analysisCount": 10,
		"thresholdScore": 5,
		"projectName": "Task Master",
		"usedResearch": true
	},
	"complexityAnalysis": [
		{
			"taskId": 1,
			"taskTitle": "Create TypeScript interfaces for declarative schema export",
			"complexityScore": 2,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Break down the TypeScript interface creation into: (1) Create export directory and file structure, (2) Define DeclarativeSchemaOutput interface with version/mode/timestamps/fingerprints, (3) Define FileEntry and FileMetadata interfaces with path/order/sql/metadata fields, (4) Define FileCategory union type and CATEGORY_PRIORITY constant mapping, (5) Add comprehensive TSDoc comments and ensure all types are properly exported.",
			"reasoning": "This is a straightforward TypeScript type definition task. The codebase already has excellent patterns to follow (plan/types.ts uses similar structures). The interfaces are well-specified with no ambiguity. The main work is mechanical: defining types, creating the constant object, and adding tests. Complexity is low because there's no business logic, just type definitions. The subtask breakdown follows natural atomic steps."
		},
		{
			"taskId": 2,
			"taskTitle": "Implement file path mapper for all object types",
			"complexityScore": 7,
			"recommendedSubtasks": 4,
			"expansionPrompt": "Divide the file mapper implementation into: (1) Implement core getFilePath function with exhaustive switch and cluster-wide object mappings (roles, extensions, settings, publications, etc.), (2) Add schema-scoped object mappings (schemas, tables, views, mviews, functions, procedures, types, domains, sequences, etc.), (3) Implement child object mappings (indexes, triggers, policies, constraints) and special policy detection logic (isTablePolicyChange helper for FK constraints and triggers), (4) Complete exhaustive switch with remaining objects (collations, text search, event triggers, casts, etc.) and finalize never check for TypeScript exhaustiveness validation.",
			"reasoning": "This task has medium-high complexity due to: (1) Need to handle 30+ PostgreSQL object types with exhaustive switch statements, (2) Special routing logic for FK constraints and triggers to policies/ directory requires business logic understanding, (3) Must integrate with existing helpers (getObjectSchema, getParentInfo) which requires understanding the Change type structure, (4) Exhaustive never checks require careful TypeScript typing. However, the codebase provides excellent reference implementations in hierarchy.ts (lines 273-574) showing exhaustive switches. The task is well-specified but requires careful attention to all edge cases."
		},
		{
			"taskId": 3,
			"taskTitle": "Implement change grouping and file ordering logic",
			"complexityScore": 5,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Split the grouping logic into: (1) Implement core file grouping with Map-based data structure that collects changes by file path and tracks minimum topological position for each group, (2) Implement two-level sorting algorithm that orders FileGroup arrays first by CATEGORY_PRIORITY (primary sort key) then by minTopoPosition (secondary sort key) to ensure correct execution order, (3) Create comprehensive unit tests validating grouping correctness, category ordering, topological ordering, and statement order preservation within files.",
			"reasoning": "Medium complexity task requiring: (1) Map-based grouping algorithm - straightforward but needs correct position tracking, (2) Two-level sort with category priority and topological ordering - the logic is clear but must preserve dependency guarantees from sortChanges, (3) Understanding of topological sort preservation - why minimum position matters for dependency ordering. The algorithm is well-specified and has a clear implementation path. The main complexity is ensuring correctness of the ordering logic, which is critical for SQL execution safety."
		},
		{
			"taskId": 4,
			"taskTitle": "Implement main exportDeclarativeSchema function",
			"complexityScore": 6,
			"recommendedSubtasks": 4,
			"expansionPrompt": "Divide the export function into: (1) Implement CREATE operation filtering to extract only 'create' changes representing final state (not migration deltas), (2) Integrate serialization DSL with grouped changes using applySerializationOptions from existing DSL helpers, (3) Generate source and target fingerprints using buildPlanScopeFingerprint with filtered CREATE changes for drift detection, (4) Assemble complete DeclarativeSchemaOutput JSON structure with metadata, fingerprints, and FileEntry array with proper order indices and SQL concatenation.",
			"reasoning": "Medium-high complexity due to: (1) Must understand difference between declarative (final state) vs migration (delta) approaches - filtering to CREATE only is conceptually important, (2) Integration with existing DSL infrastructure (applySerializationOptions) requires understanding serialization pipeline, (3) Fingerprint generation for drift detection requires understanding catalog hashing, (4) Must reuse patterns from createPlan in plan/create.ts but adapt for declarative context. The function is well-specified with clear reference implementation to follow (createPlan shows similar workflow). The main challenge is correct integration of multiple subsystems."
		},
		{
			"taskId": 5,
			"taskTitle": "Create integration test helper for declarative export",
			"complexityScore": 6,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Break the test helper into: (1) Create basic testDeclarativeExport() helper structure with database setup, catalog extraction, change generation, export invocation, and structural output validation (version, mode, files array, fingerprints), (2) Add file execution validation phase that creates fresh database, executes exported files in order, and validates no SQL errors occur with proper error context and cleanup, (3) Implement fingerprint verification of final state by extracting catalog after execution, computing fingerprint from stableIds, and comparing with target fingerprint with detailed error reporting for mismatches.",
			"reasoning": "Medium-high complexity because: (1) Must integrate with existing testcontainers infrastructure (containerManager patterns from roundtrip.ts), (2) Requires creating fresh database for execution validation (getDatabasePair pattern), (3) Fingerprint verification involves catalog extraction and stableId hashing - complex but well-documented in roundtrip.ts (lines 147-222), (4) Error reporting must be detailed with SQL context and remaining changes, (5) Proper cleanup and resource management is critical. The reference implementation in roundtrip.ts provides excellent guidance, but adapting it for declarative export requires understanding the differences in workflow."
		},
		{
			"taskId": 6,
			"taskTitle": "Write integration tests for simple schemas",
			"complexityScore": 4,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Organize tests into: (1) Create test file and implement basic object tests (simple table, table with index, multiple schemas) using testDeclarativeExport helper following table-operations.test.ts patterns, (2) Add cluster-wide object tests (roles, extensions) that validate objects without schema scope are correctly exported to cluster/ directory, (3) Add schema-scoped object tests (views, functions, sequences) that validate complex objects and dependency ordering.",
			"reasoning": "Medium-low complexity as this is primarily test case authoring: (1) Test file structure is straightforward following existing patterns (table-operations.test.ts), (2) testDeclarativeExport helper abstracts complexity (created in Task 5), (3) Test cases are well-specified with clear SQL examples, (4) Main work is mechanical: write test cases, run them, verify they pass. The complexity comes from ensuring test coverage is comprehensive and understanding what each test validates. Integration with testcontainers is handled by existing infrastructure."
		},
		{
			"taskId": 7,
			"taskTitle": "Write integration tests for complex dependencies",
			"complexityScore": 7,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Break complex dependency tests into: (1) Foreign key constraints test validating FK SQL appears in policies/ directory not tables/, (2) Triggers test validating triggers execute after dependencies and appear in policies/, (3) RLS policies test validating both ALTER TABLE ENABLE RLS and CREATE POLICY execute in correct order, (4) Partitioned tables test validating parent-child relationships and execution ordering, (5) Materialized views with indexes test validating multi-level dependency chains (table → mview → index).",
			"reasoning": "High complexity due to: (1) Tests must validate critical file routing logic (FK/triggers to policies/) which is a key design decision requiring special detection logic, (2) Partitioned tables involve catalog lookup logic (isPartitionTable patterns from hierarchy.ts lines 154-200), (3) Must validate execution order across multiple dependency levels, (4) Tests need to inspect output structure AND verify SQL execution correctness, (5) Materialized views with indexes test multi-hop dependencies. These tests validate the most complex aspects of the feature and require deep understanding of PostgreSQL object dependencies. The task is well-specified but requires careful test design to validate correctness."
		},
		{
			"taskId": 8,
			"taskTitle": "Handle edge cases for all object types",
			"complexityScore": 8,
			"recommendedSubtasks": 6,
			"expansionPrompt": "Organize edge case handling into: (1) Implement cluster-wide object mappings (roles, extensions, languages) with exhaustive switch and never checks, (2) Add foreign data wrapper ecosystem mappings (fdw, server, user_mapping sharing cluster/foreign_data_wrappers.sql), (3) Add cluster replication and event trigger mappings (publications, subscriptions, event_triggers), (4) Implement schema-scoped parent objects (tables, views, mviews, foreign_tables) with correct category assignment, (5) Add type system and domain mappings (enums/composite_types/ranges sharing types.sql, domains getting individual files, sequences, schemas), (6) Implement child objects and special cases (indexes, triggers, policies, FK constraints routing, default privileges, procedures, aggregates, collations).",
			"reasoning": "High complexity because: (1) Must implement exhaustive handling for 30+ PostgreSQL object types - this is the most comprehensive mapping task, (2) Special cases like FDW ecosystem sharing files requires grouping logic, (3) FK constraint detection (isTablePolicyChange) requires understanding table change types and instanceof checks, (4) Must integrate with getParentInfo() for child objects, (5) Comprehensive unit tests for each object type doubles the work, (6) TypeScript exhaustiveness validation must be maintained. This task completes the file mapper with production-quality coverage. The codebase provides reference (hierarchy.ts has all object types), but implementing and testing all cases is substantial work."
		},
		{
			"taskId": 9,
			"taskTitle": "Export public API from package index",
			"complexityScore": 3,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Structure API export into: (1) Add declarative schema exports to src/index.ts following existing export patterns, (2) Update package.json exports field with subpath export for './export' entry point, (3) Run TypeScript build with `pnpm build` to compile source and generate .d.ts files, (4) Verify generated type definitions in dist/index.d.ts contain all exported types and functions, (5) Create import validation test file to ensure all exports are accessible and types resolve correctly.",
			"reasoning": "Low-medium complexity as this is primarily configuration: (1) Adding exports to index.ts is mechanical following existing patterns, (2) package.json exports field update is straightforward, (3) Build verification is simple but critical, (4) Type definition validation ensures public API is correct. The main complexity is ensuring the build system correctly processes the new exports and type definitions are generated properly. The task is well-specified with clear validation steps."
		},
		{
			"taskId": 10,
			"taskTitle": "Write documentation and usage examples",
			"complexityScore": 4,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Organize documentation into: (1) Add comprehensive JSDoc comments to public API (exportDeclarativeSchema function with @param/@returns/@example tags, DeclarativeSchemaOutput/FileEntry/FileCategory interfaces with property documentation) following TSDoc standards, (2) Add inline code comments explaining design decisions (why FK/triggers map to policies/, category priority ordering rationale, topological sort preservation), (3) Validate documentation completeness by checking build output, IDE rendering, example code compilation, and coverage of all public exports.",
			"reasoning": "Medium-low complexity as this is documentation authoring: (1) JSDoc follows standard TSDoc format with clear examples, (2) Inline comments explain non-obvious design choices (policies routing, ordering logic), (3) Validation ensures documentation renders correctly in IDEs and examples compile. The main work is writing clear, accurate documentation and ensuring examples are correct. Complexity comes from understanding the feature well enough to explain design decisions clearly. The task explicitly avoids creating separate markdown files, keeping scope focused."
		}
	]
}