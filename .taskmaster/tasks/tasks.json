{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Core Formatter Module",
        "description": "Create SqlFormatOptions interface, SqlFormatter class, and unit tests",
        "details": "Create src/core/format/ directory with:\n- format.types.ts: Define SqlFormatOptions interface with enabled (default false), keywordCase ('preserve'|'upper'|'lower', default 'upper'), lineWidth (default 80), indentWidth (default 2), commaStyle ('trailing'|'leading', default 'trailing'), alignColumns (boolean, default true). Export DEFAULT_FORMAT_OPTIONS constant.\n- format.ts: Implement SqlFormatter class with constructor accepting SqlFormatOptions and methods:\n  * keyword(kw: string): string - Transform keyword to configured case\n  * indent(level?: number): string - Create indentation string (spaces * indentWidth * level)\n  * list(items: string[], indent?: number): string - Join items with proper comma placement and line breaks\n  * parens(content: string, multiline?: boolean): string - Wrap content in parentheses\n  * alignColumns(rows: string[][], separators?: string[]): string[] - Align multi-column data (e.g., column definitions) by padding each column to max width. Takes array of rows where each row is array of column values. Optional separators array defines what goes between columns (default single space). Returns array of aligned row strings.\n- format.test.ts: Unit tests for all methods covering edge cases (empty lists, special characters, all option combinations)\n- index.ts: Export all types and classes",
        "testStrategy": "Unit tests in format.test.ts using Vitest. Test keyword() with all case options, indent() with various levels, list() with trailing/leading commas, parens() with single/multiline. Test with empty inputs and special characters.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create directory structure and format.types.ts with SqlFormatOptions interface",
            "description": "Create src/core/format/ directory and implement the type definitions for the formatter configuration options.",
            "dependencies": [],
            "details": "Create src/core/format/ directory structure. In format.types.ts, define SqlFormatOptions interface with properties: enabled (boolean, default false), keywordCase ('preserve'|'upper'|'lower', default 'upper'), lineWidth (number, default 80), indentWidth (number, default 2), commaStyle ('trailing'|'leading', default 'trailing'), alignColumns (boolean, default true). Export DEFAULT_FORMAT_OPTIONS constant object with all default values. Create index.ts to export all types.",
            "status": "pending",
            "testStrategy": "Type checking via TypeScript compilation. Verify DEFAULT_FORMAT_OPTIONS has correct structure and values."
          },
          {
            "id": 2,
            "title": "Implement SqlFormatter class with keyword(), indent(), and helper methods",
            "description": "Implement the core SqlFormatter class with basic formatting methods for keywords, indentation, and parentheses wrapping.",
            "dependencies": [
              1
            ],
            "details": "In src/core/format/format.ts, implement SqlFormatter class with constructor accepting SqlFormatOptions. Implement methods: keyword(kw: string): string to transform keywords based on keywordCase option (preserve, toUpperCase(), toLowerCase()), indent(level?: number): string to generate indentation string (repeat spaces by indentWidth * level, default level=1), parens(content: string, multiline?: boolean): string to wrap content in parentheses with optional newlines for multiline mode. Update index.ts to export SqlFormatter class.",
            "status": "pending",
            "testStrategy": "Unit tests for keyword() with all three case options, indent() with levels 0-3, parens() with single-line and multi-line modes."
          },
          {
            "id": 3,
            "title": "Implement list() method with comma style logic",
            "description": "Add the list formatting method to SqlFormatter class with support for trailing and leading comma styles.",
            "dependencies": [
              2
            ],
            "details": "In src/core/format/format.ts, implement list(items: string[], indent?: number): string method in SqlFormatter class. For trailing comma style: join items with ',\\n' + indentation. For leading comma style: join items with '\\n' + indentation + ', ' (except first item). Handle edge cases: empty array returns empty string, single item returns item without comma, respect indent parameter (default to 0). Consider lineWidth for potential future line-breaking logic.",
            "status": "pending",
            "testStrategy": "Unit tests verify trailing vs leading comma styles, empty arrays, single-item arrays, multi-item arrays with various indent levels."
          },
          {
            "id": 4,
            "title": "Implement alignColumns() method for tabular alignment",
            "description": "Add the alignColumns method to SqlFormatter class to align multi-column data like table column definitions.",
            "dependencies": [
              2
            ],
            "details": "In src/core/format/format.ts, implement alignColumns(rows: string[][], separators?: string[]): string[] method in SqlFormatter class. The method takes an array of rows where each row is an array of column values (e.g., [['id', 'bigserial', 'PRIMARY KEY'], ['name', 'text', 'NOT NULL']]). Calculate max width for each column position across all rows. Pad each column value to its max width using padEnd(). Join columns with separators (default single space between each). Return array of aligned row strings. Handle edge cases: empty rows array, rows with different column counts (pad shorter rows), null/undefined values. When alignColumns option is false, skip padding and just join with single space.",
            "status": "pending",
            "testStrategy": "Unit tests verify column alignment with various inputs: uniform column counts, varying column counts, empty values, special characters. Test with alignColumns=true and alignColumns=false."
          },
          {
            "id": 5,
            "title": "Create comprehensive unit tests covering all methods and edge cases",
            "description": "Implement comprehensive test suite for SqlFormatter class covering all methods, option combinations, and edge cases.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create src/core/format/format.test.ts using Vitest. Test suites: (1) keyword() - test preserve/upper/lower with various keywords, special characters, empty strings, mixed case input; (2) indent() - test levels 0-5, undefined level, negative level; (3) list() - test trailing/leading comma styles, empty/single/multiple items, various indent levels, items with special characters; (4) parens() - test single-line vs multiline, empty content, content with newlines, nested parentheses; (5) alignColumns() - test uniform columns, varying column counts, empty values, alignColumns=true/false; (6) Integration tests combining multiple methods; (7) Test DEFAULT_FORMAT_OPTIONS are applied correctly in constructor.",
            "status": "pending",
            "testStrategy": "Run with 'npm test' or 'vitest'. Aim for 100% code coverage. Verify all option combinations produce expected output strings."
          }
        ]
      },
      {
        "id": 2,
        "title": "Extend SerializeOptions with Format Support",
        "description": "Update serialization infrastructure to accept and pass format options",
        "details": "- Update src/core/integrations/serialize/serialize.types.ts: Add format?: SqlFormatOptions to SerializeOptions type\n- Update src/core/integrations/serialize/dsl.ts: Import SqlFormatOptions from format module. Modify SerializeOptions type to include format field. Update compileSerializeDSL to pass format options through to change.serialize() via rule.options\n- Update BaseChange.serialize() signature in src/core/objects/base.change.ts to accept options?: SerializeOptions (already uses Record<string, unknown>, verify it accommodates format field)",
        "testStrategy": "Type checking ensures format field is correctly typed. Integration tests in later tasks will verify format options flow through to serialize methods.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Import SqlFormatOptions type in serialize modules",
            "description": "Add import statements for SqlFormatOptions from the core/format module into serialize.types.ts and dsl.ts",
            "dependencies": [],
            "details": "Add import statement for SqlFormatOptions type from src/core/format module. This assumes Task 1 has created the format module with SqlFormatOptions interface. The import will be: `import type { SqlFormatOptions } from '../../format'` in both serialize.types.ts and dsl.ts files.",
            "status": "pending",
            "testStrategy": "TypeScript compilation will verify the import path is correct and the type exists. No runtime tests needed for import statements."
          },
          {
            "id": 2,
            "title": "Add format field to SerializeOptions type in dsl.ts",
            "description": "Extend the SerializeOptions type definition to include optional format field of type SqlFormatOptions",
            "dependencies": [
              1
            ],
            "details": "Update SerializeOptions type in src/core/integrations/serialize/dsl.ts (lines 14-18). Add `format?: SqlFormatOptions;` field to the type definition. This extends the existing type which already has skipAuthorization and index signature for unknown values. The format field will be optional to maintain backward compatibility.",
            "status": "pending",
            "testStrategy": "TypeScript type checking ensures the field is correctly typed. Create a test SerializeOptions object with format field and verify it compiles without errors."
          },
          {
            "id": 3,
            "title": "Create SerializeOptions type in serialize.types.ts",
            "description": "Define a standalone SerializeOptions type in serialize.types.ts that includes the format field, to be used as the canonical type definition",
            "dependencies": [
              1
            ],
            "details": "Create a new exported SerializeOptions type in src/core/integrations/serialize/serialize.types.ts with fields: skipAuthorization?: boolean and format?: SqlFormatOptions. This provides a centralized type definition that can be imported by other modules.",
            "status": "pending",
            "testStrategy": "TypeScript compilation verifies the type is correctly defined and exported. Verify it can be imported in other modules without errors."
          },
          {
            "id": 4,
            "title": "Update dsl.ts to import and use SerializeOptions from serialize.types.ts",
            "description": "Replace the local SerializeOptions type in dsl.ts with an import from serialize.types.ts to eliminate duplication",
            "dependencies": [
              2,
              3
            ],
            "details": "In src/core/integrations/serialize/dsl.ts, remove the local SerializeOptions type definition (lines 14-18) and replace it with: `import type { SerializeOptions } from './serialize.types.ts'`. Update the SerializeRule type to reference the imported type. This eliminates duplication and ensures consistency across the codebase.",
            "status": "pending",
            "testStrategy": "TypeScript compilation verifies the import works correctly. All existing code using SerializeOptions should continue to compile without changes. Run existing serialize DSL tests to ensure no behavioral changes."
          },
          {
            "id": 5,
            "title": "Verify BaseChange.serialize() accepts SerializeOptions",
            "description": "Verify that BaseChange.serialize() method signature in base.change.ts can accept the updated SerializeOptions type with format field",
            "dependencies": [
              3,
              4
            ],
            "details": "Check src/core/objects/base.change.ts line 54. The current signature is `serialize(options?: Record<string, unknown>): string`. Verify that SerializeOptions (with format field) is assignable to Record<string, unknown>. Since SerializeOptions has an index signature [key: string]: unknown, it should be compatible. If needed, update the signature to `serialize(options?: SerializeOptions): string` for better type safety, but this is optional since Record<string, unknown> already accommodates it.",
            "status": "pending",
            "testStrategy": "Create a test that instantiates a concrete Change subclass and calls serialize() with SerializeOptions containing a format field. TypeScript compilation verifies type compatibility. No runtime behavior changes expected."
          }
        ]
      },
      {
        "id": 3,
        "title": "Add Format Options to Plan Schema",
        "description": "Update plan types to store and pass format options through plan lifecycle",
        "details": "- Update src/core/plan/types.ts:\n  * Import SqlFormatOptions from core/format\n  * Add format?: SqlFormatOptions to CreatePlanOptions interface\n  * Add format: z.any().optional() to PlanSchema with comment indicating SqlFormatOptions type\n- Update src/core/plan/create.ts:\n  * Import SqlFormatOptions\n  * Accept format in CreatePlanOptions\n  * Store format in plan JSON\n  * Pass format through to generateStatements via serialize options\n- Ensure format options are preserved in plan serialization/deserialization",
        "testStrategy": "Unit tests verify format options are stored in plan JSON and retrieved correctly. Test plan creation with format options, serialize to JSON, deserialize, and verify format options match.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update plan types.ts with SqlFormatOptions",
            "description": "Add SqlFormatOptions interface to CreatePlanOptions and PlanSchema in src/core/plan/types.ts",
            "dependencies": [],
            "details": "Import SqlFormatOptions from '../format/format.types'. Add optional 'format?: SqlFormatOptions' property to CreatePlanOptions interface (following existing pattern of filter/serialize properties). Update PlanSchema Zod schema to include 'format: z.any().optional()' with a comment '// SqlFormatOptions type' (matching the pattern used for filter/serialize on lines 135-136). This establishes the type foundation for format options in the plan lifecycle.",
            "status": "pending",
            "testStrategy": "Type checking validates SqlFormatOptions import and CreatePlanOptions interface. Schema validation tests in subsequent subtask will verify Zod schema accepts format options correctly."
          },
          {
            "id": 2,
            "title": "Update create.ts to accept and store format options",
            "description": "Modify src/core/plan/create.ts to accept format parameter, store in plan JSON, and pass through to generateStatements",
            "dependencies": [
              1
            ],
            "details": "Import SqlFormatOptions from '../format/format.types'. Update createPlan function to extract format from CreatePlanOptions parameter. Store format in the plan object JSON structure. When calling generateStatements, pass format through via serialize options object (e.g., { filter: dslFilter, serialize: dslSerialize, format: format }). Ensure format options flow through the entire plan creation pipeline from input to statement generation.",
            "status": "pending",
            "testStrategy": "Unit tests verify format options are correctly extracted from CreatePlanOptions, stored in plan JSON structure, and passed to generateStatements. Mock generateStatements to verify it receives format options in serialize options parameter."
          },
          {
            "id": 3,
            "title": "Add unit tests for plan serialization with format options",
            "description": "Create comprehensive unit tests verifying format options are preserved through plan serialization and deserialization",
            "dependencies": [
              1,
              2
            ],
            "details": "Add tests in src/core/plan/create.test.ts (or appropriate test file) that: (1) Create a plan with specific format options (e.g., { enabled: true, keywordCase: 'upper', indentWidth: 4 }), (2) Serialize the plan to JSON using PlanSchema, (3) Deserialize the JSON back to a plan object, (4) Verify format options match the original values. Test with various format option combinations including undefined/null format (should work without errors). Test that format options are correctly passed through to statement generation.",
            "status": "pending",
            "testStrategy": "Vitest unit tests with assertions comparing input format options against serialized/deserialized format options. Verify PlanSchema.parse() accepts plans with format options. Test edge cases: missing format, partial format options, all format options specified."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement CREATE TABLE Formatting",
        "description": "Add formatted output support to CreateTable change with columns on separate lines and aligned column definitions",
        "details": "Update src/core/objects/table/changes/table.create.ts:\n- Import SqlFormatter and SqlFormatOptions from core/format\n- Update serialize(options?: SerializeOptions) signature\n- Check if options?.format?.enabled is true\n- If disabled or undefined, use existing serialization (no changes)\n- If enabled, create private serializeFormatted(formatter: SqlFormatter) method:\n  * Use formatter.keyword() for CREATE, TABLE, TEMPORARY, UNLOGGED, PARTITION OF, INHERITS, PARTITION BY, WITH\n  * For regular tables: columns one per line with formatter.indent(1), joined with formatter.list()\n  * Use formatter.alignColumns() to align column names, data types, and constraints in columns\n  * Example output with alignment:\n    CREATE TABLE public.orders (\n      id            bigserial   PRIMARY KEY,\n      customer_id   bigint      NOT NULL,\n      status        text        NOT NULL DEFAULT 'pending',\n      notes         text\n    )\n  * Handle INHERITS clause on new line\n  * Handle PARTITION BY on new line\n  * Handle WITH on new line\n  * For partition tables: format PARTITION OF parent FOR VALUES on multiple lines\n- Add unit tests for formatted output with various option combinations including alignColumns=true/false",
        "testStrategy": "Unit tests in table.create.test.ts verify formatted output with all option combinations (keyword case, comma style, indent width, alignColumns). Test regular tables with column alignment, partitioned tables, partition children, inherited tables, tables with storage parameters. Verify column names, types, and constraints align in columns when alignColumns=true.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update serialize() signature and add format enabled check",
            "description": "Modify the CreateTable class serialize() method to accept SerializeOptions parameter and check if formatting is enabled before proceeding",
            "dependencies": [],
            "details": "In src/core/objects/table/changes/table.create.ts:\n- Import SqlFormatter, SqlFormatOptions from core/format (module to be created in parent task dependencies)\n- Import SerializeOptions from core/integrations/serialize\n- Change serialize() signature from serialize(): string to serialize(options?: SerializeOptions): string\n- At the beginning of serialize(), check if options?.format?.enabled === true\n- If format is disabled or undefined, use existing serialization logic (lines 92-187) unchanged\n- If format is enabled, call new private serializeFormatted(options.format) method (to be implemented in subsequent subtasks)\n- This provides the branching point between compact and formatted output",
            "status": "pending",
            "testStrategy": "Verify signature change compiles without errors. Existing unit tests in table.create.test.ts should continue passing without modification when format options are not provided (backward compatibility check)."
          },
          {
            "id": 2,
            "title": "Implement serializeFormatted() for regular tables with aligned column formatting",
            "description": "Create private serializeFormatted method to format regular CREATE TABLE statements with columns on separate lines, proper indentation, and aligned column definitions",
            "dependencies": [
              1
            ],
            "details": "In src/core/objects/table/changes/table.create.ts:\n- Create private serializeFormatted(formatOptions: SqlFormatOptions): string method\n- Instantiate SqlFormatter with formatOptions: const formatter = new SqlFormatter(formatOptions)\n- Build CREATE/TEMPORARY/UNLOGGED/TABLE header using formatter.keyword() for each keyword\n- Early return for partition tables (check this.table.partition_bound) - defer to subtask 4\n- For regular tables with columns:\n  * Build column definitions as rows of columns: [[name, type, constraints], ...]\n  * Column 1: column name\n  * Column 2: data_type_str (with COLLATE if present)\n  * Column 3: constraints (identity/generated/default, NOT NULL combined)\n  * Use formatter.alignColumns(columnRows) to align all columns\n  * Use formatter.keyword() for COLLATE, GENERATED, ALWAYS, AS, IDENTITY, BY, DEFAULT, STORED, NOT, NULL keywords\n  * Join aligned columns using formatter.list(alignedColumnDefinitions, 1) for comma placement and indentation level 1\n  * Wrap in parentheses using formatter.parens(formattedColumns, true) for multiline\n  * Example output:\n    id            bigserial   PRIMARY KEY,\n    customer_id   bigint      NOT NULL,\n    status        text        NOT NULL DEFAULT 'pending'\n- Handle empty column case: return just \"()\" without multiline formatting",
            "status": "pending",
            "testStrategy": "Add unit tests in table.create.test.ts:\n- Test regular table with multiple columns formats with columns on separate lines AND aligned\n- Test column alignment with varying name lengths and type lengths\n- Test column with identity (GENERATED ALWAYS/BY DEFAULT AS IDENTITY)\n- Test column with generated stored expression\n- Test column with default value\n- Test column with NOT NULL constraint\n- Test column with COLLATE clause\n- Test different keyword cases (upper, lower, preserve)\n- Test different comma styles (trailing, leading)\n- Test different indent widths (2, 4)\n- Test alignColumns=false produces non-aligned output\n- Test empty table (no columns)"
          },
          {
            "id": 3,
            "title": "Add formatting for INHERITS, PARTITION BY, and WITH clauses",
            "description": "Extend serializeFormatted() to handle INHERITS, PARTITION BY, and WITH storage parameter clauses on separate lines",
            "dependencies": [
              2
            ],
            "details": "In src/core/objects/table/changes/table.create.ts, within serializeFormatted():\n- After column definitions, build array of additional clause lines (not indented, same level as CREATE)\n- INHERITS clause (lines 164-174 logic):\n  * Check if this.table.parent_schema && this.table.parent_name && !this.table.partition_bound\n  * Format: formatter.keyword('INHERITS') + ' (' + this.table.parent_schema + '.' + this.table.parent_name + ')'\n  * Add to clause array\n- PARTITION BY clause (lines 176-179 logic):\n  * Check if this.table.partition_by exists\n  * Format: formatter.keyword('PARTITION BY') + ' ' + this.table.partition_by\n  * Add to clause array\n- WITH clause (lines 181-184 logic):\n  * Check if this.table.options exists and length > 0\n  * Format: formatter.keyword('WITH') + ' (' + this.table.options.join(', ') + ')'\n  * Add to clause array\n- Join all parts: header + formatted columns + clauses.join('\\n')\n- Each clause on its own line, not indented (PostgreSQL standard formatting)",
            "status": "pending",
            "testStrategy": "Add unit tests in table.create.test.ts:\n- Test table with INHERITS clause formats correctly\n- Test partitioned table (parent) with PARTITION BY RANGE/LIST/HASH\n- Test table with WITH storage parameters (fillfactor, autovacuum_enabled, etc.)\n- Test table with all three clauses combined\n- Test keyword case transformation for INHERITS, PARTITION, BY, WITH\n- Verify clauses are not indented (same level as CREATE)"
          },
          {
            "id": 4,
            "title": "Add formatting for partition tables (PARTITION OF ... FOR VALUES)",
            "description": "Implement formatting logic for partition child tables that use PARTITION OF syntax instead of column definitions",
            "dependencies": [
              1
            ],
            "details": "In src/core/objects/table/changes/table.create.ts, within serializeFormatted():\n- Near the beginning, add check: if (this.table.parent_schema && this.table.parent_name && this.table.partition_bound)\n- This is partition child table case (lines 108-119 logic)\n- Format output on multiple lines:\n  * Line 1: CREATE [TEMPORARY|UNLOGGED] TABLE schema.name\n  * Line 2 (not indented): PARTITION OF parent_schema.parent_name\n  * Line 3 (not indented): partition_bound value (e.g., FOR VALUES FROM ... TO ...)\n- Use formatter.keyword() for CREATE, TEMPORARY, UNLOGGED, TABLE, PARTITION, OF\n- Do NOT format partition_bound string (it comes from PostgreSQL catalog, already formatted)\n- Join lines with '\\n'\n- Return early - partition tables do not have column definitions or other clauses",
            "status": "pending",
            "testStrategy": "Add unit tests in table.create.test.ts:\n- Test partition child table with RANGE partition bound\n- Test partition child table with LIST partition bound\n- Test partition child table with HASH partition bound\n- Test TEMPORARY partition table\n- Test UNLOGGED partition table\n- Verify partition_bound string is preserved as-is without reformatting\n- Verify keyword case transformation applied to PARTITION OF\n- Verify lines are not indented (PostgreSQL standard)"
          },
          {
            "id": 5,
            "title": "Create comprehensive unit tests for all table types and format options",
            "description": "Add complete test suite covering all CREATE TABLE variants with all formatting option combinations",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "In src/core/objects/table/changes/table.create.test.ts:\n- Add new describe block: describe.concurrent('table.create - formatted output')\n- Test format disabled (backward compatibility): all existing tests should pass with options.format.enabled = false\n- Test all table types with format enabled:\n  * Regular table with multiple columns (identity, generated, defaults, NOT NULL, COLLATE)\n  * Empty table (no columns)\n  * TEMPORARY table\n  * UNLOGGED table\n  * Table with INHERITS\n  * Partitioned parent table with PARTITION BY RANGE/LIST/HASH\n  * Partition child table with FOR VALUES\n  * Table with WITH storage parameters\n  * Complex table combining multiple features\n- Test all keyword case options: 'upper', 'lower', 'preserve'\n- Test both comma styles: 'trailing', 'leading'\n- Test multiple indent widths: 2, 4\n- Verify output matches expected multiline formatted SQL\n- Use snapshot testing or exact string matching for verification",
            "status": "pending",
            "testStrategy": "All tests in this subtask ARE the test strategy. Run: npm test -- table.create.test.ts. Verify:\n- All tests pass\n- Code coverage for serialize() and serializeFormatted() is >95%\n- All code paths exercised (partition vs regular, with/without clauses)\n- Edge cases covered (empty columns, null options, etc.)"
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement CREATE TYPE ENUM Formatting",
        "description": "Add formatted output support to CreateEnum with values on separate lines",
        "details": "Update src/core/objects/type/enum/changes/enum.create.ts:\n- Import SqlFormatter and SqlFormatOptions from core/format\n- Update serialize(options?: SerializeOptions) signature\n- Check if options?.format?.enabled is true\n- If disabled, use existing compact serialization\n- If enabled, create private serializeFormatted(formatter: SqlFormatter) method:\n  * Use formatter.keyword() for CREATE TYPE, AS ENUM\n  * Format enum labels one per line with formatter.indent(1)\n  * Use formatter.list() with quoteLiteral(label) for each label\n  * Apply formatter.parens() with multiline=true\n- Add unit tests for formatted output",
        "testStrategy": "Unit tests verify formatted enum output with different keyword cases, comma styles, and indent widths. Test with empty enums, single value, multiple values.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update serialize() method with format options check",
            "description": "Modify the CreateEnum.serialize() method signature to accept SerializeOptions and add conditional logic to check if formatting is enabled",
            "dependencies": [],
            "details": "In src/core/objects/type/enum/changes/enum.create.ts:\n- Import SqlFormatter and SqlFormatOptions from '../../../../format'\n- Update serialize() signature from serialize(): string to serialize(options?: SerializeOptions): string (where SerializeOptions comes from serialize.types.ts)\n- Add conditional check: if (!options?.format?.enabled) return existing compact serialization (lines 41-54)\n- If format is enabled, call private serializeFormatted() method passing new SqlFormatter(options.format)\n- This establishes the entry point for formatted vs compact output",
            "status": "pending",
            "testStrategy": "Manual verification that method signature accepts options parameter. Functional testing will be covered in subtask 3 after serializeFormatted() is implemented."
          },
          {
            "id": 2,
            "title": "Implement serializeFormatted() method for enum labels",
            "description": "Create private serializeFormatted() method that uses SqlFormatter helpers to generate multiline enum output with proper indentation and comma placement",
            "dependencies": [
              1
            ],
            "details": "In src/core/objects/type/enum/changes/enum.create.ts:\n- Add private serializeFormatted(formatter: SqlFormatter): string method\n- Build SQL using formatter helpers:\n  * Line 1: formatter.keyword('CREATE TYPE') + space + schema.name + space + formatter.keyword('AS ENUM')\n  * Use formatter.list() to format enum labels with indent level 1\n  * For each label in this.enum.labels, use quoteLiteral(label.label) to escape\n  * Apply formatter.parens() with multiline=true to wrap the list\n- Result structure: CREATE TYPE schema.name AS ENUM (\\n  'label1',\\n  'label2'\\n)\n- Handle edge case of empty enum (no labels)",
            "status": "pending",
            "testStrategy": "Unit tests verify formatter methods are called correctly. Integration tests in subtask 3 will verify actual formatted output."
          },
          {
            "id": 3,
            "title": "Add comprehensive unit tests for formatted enum output",
            "description": "Create unit tests in enum.create.test.ts that verify formatted enum serialization with various formatting options and edge cases",
            "dependencies": [
              1,
              2
            ],
            "details": "In src/core/objects/type/enum/changes/enum.create.test.ts:\n- Add test cases for formatted output with options?.format?.enabled = true\n- Test keyword case variations (upper, lower, preserve): verify 'CREATE TYPE' vs 'create type' vs 'Create Type'\n- Test comma styles (trailing, leading): verify label list has commas at end vs start of lines\n- Test indent widths (2, 4): verify enum labels indented correctly\n- Test edge cases:\n  * Empty enum (no labels) - should produce CREATE TYPE name AS ENUM ()\n  * Single label - verify one label formatted correctly\n  * Multiple labels (3+) - verify all labels on separate lines\n- Test that format disabled (options undefined or enabled=false) uses compact serialization\n- Each test should construct Enum model, CreateEnum change, call serialize(options), and assert expected formatted SQL string",
            "status": "pending",
            "testStrategy": "Unit tests serve as the test strategy - they directly verify formatted SQL output matches expected strings for all option combinations and edge cases. Run with npm test or vitest."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement CREATE TYPE COMPOSITE and Other Type Formatting",
        "description": "Add formatted output support to CreateCompositeType with attributes on separate lines",
        "details": "Update src/core/objects/type/composite-type/changes/composite-type.create.ts:\n- Import SqlFormatter and SqlFormatOptions from core/format\n- Update serialize(options?: SerializeOptions) signature\n- Check if options?.format?.enabled is true\n- If disabled, use existing compact serialization\n- If enabled, create private serializeFormatted(formatter: SqlFormatter) method:\n  * Use formatter.keyword() for CREATE TYPE, AS\n  * Format attributes one per line: column.name, column.data_type_str, COLLATE collation\n  * Use formatter.indent(1) for attribute definitions\n  * Use formatter.list() to join attributes\n  * Apply formatter.parens() with multiline=true\n- Add unit tests for formatted output",
        "testStrategy": "Unit tests verify formatted composite type output with attributes including collations. Test with empty composite types, single attribute, multiple attributes with various data types and collations.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update serialize() signature and add format check with serializeFormatted() method",
            "description": "Modify the CreateCompositeType class to accept SerializeOptions, check for format enablement, and delegate to a new serializeFormatted() method when formatting is enabled",
            "dependencies": [],
            "details": "In composite-type.create.ts: (1) Import SqlFormatter and SqlFormatOptions from core/format module, (2) Import SerializeOptions type, (3) Update serialize() signature from serialize(): string to serialize(options?: SerializeOptions): string, (4) Add format check: if (!options?.format?.enabled) return existing compact serialization, (5) Create new SqlFormatter instance with options.format, (6) Call and return this.serializeFormatted(formatter). This establishes the formatting infrastructure and maintains backward compatibility with compact output when formatting is disabled.",
            "status": "pending",
            "testStrategy": "Verify existing tests still pass with no options passed. Add test case calling serialize() with {format: {enabled: false}} to ensure compact output is preserved."
          },
          {
            "id": 2,
            "title": "Implement serializeFormatted() with attribute formatting and indentation",
            "description": "Create the private serializeFormatted() method that formats composite type attributes on separate lines with proper indentation, including name, data_type_str, and optional COLLATE clauses",
            "dependencies": [
              1
            ],
            "details": "Create private serializeFormatted(formatter: SqlFormatter): string method. Implementation: (1) Use formatter.keyword() for 'CREATE TYPE', 'AS' keywords, (2) Format header line: CREATE TYPE schema.name AS, (3) Map each column to formatted string: column.name, column.data_type_str, and if column.collation exists add 'COLLATE' keyword + collation value, (4) Use formatter.list() to join attribute strings with appropriate separators (handling comma-first vs comma-last style), (5) Apply formatter.indent(1) for attribute definitions to indent them, (6) Wrap attributes with formatter.parens() using multiline=true option, (7) Return complete formatted SQL string. Handle edge case of empty columns array gracefully.",
            "status": "pending",
            "testStrategy": "Manual testing during implementation with sample composite types containing 0, 1, and multiple attributes with various data types and collations."
          },
          {
            "id": 3,
            "title": "Add comprehensive unit tests for formatted composite type output",
            "description": "Create unit tests in composite-type.create.test.ts covering formatted output with various configurations including empty composites, single/multiple attributes, different data types, and collations",
            "dependencies": [
              2
            ],
            "details": "Add test cases to composite-type.create.test.ts: (1) Test empty composite type with format enabled - verify parentheses handling, (2) Test single attribute with integer type - verify single-line or minimal formatting, (3) Test multiple attributes (2-3) with mixed types (integer, text, timestamp) - verify each attribute on separate line with proper indentation, (4) Test attributes with COLLATE clauses - verify COLLATE keyword formatting and collation value placement, (5) Test different format options: keyword case (uppercase/lowercase), comma style (comma-first vs comma-last), indent width (2 vs 4 spaces), (6) Compare formatted output against expected multiline SQL strings with correct indentation and keyword casing. Each test should create CompositeType instance, instantiate CreateCompositeType, call serialize() with format options, and assert against expected formatted SQL.",
            "status": "pending",
            "testStrategy": "Run vitest tests and verify all new test cases pass. Check test coverage includes empty types, single attributes, multiple attributes, collations, and various format option combinations."
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement CREATE AGGREGATE Formatting",
        "description": "Add formatted output support to CreateAggregate with clauses on separate lines",
        "details": "Update src/core/objects/aggregate/changes/aggregate.create.ts:\n- Import SqlFormatter and SqlFormatOptions from core/format\n- Update serialize(options?: SerializeOptions) signature\n- Check if options?.format?.enabled is true\n- If disabled, use existing compact serialization (line 290: clauses.join(', '))\n- If enabled, create private serializeFormatted(formatter: SqlFormatter) method:\n  * Use formatter.keyword() for CREATE, OR REPLACE, AGGREGATE, and all clause keywords\n  * Format head: CREATE [OR REPLACE] AGGREGATE name(signature)\n  * Format each clause (SFUNC, STYPE, FINALFUNC, etc.) on separate lines with formatter.indent(1)\n  * Join clauses with newlines instead of ', '\n  * Wrap in parens: formatter.parens(clauses.join('\\n'), multiline=true)\n- Add unit tests for formatted output",
        "testStrategy": "Unit tests verify formatted aggregate output with various clauses (SFUNC, STYPE, FINALFUNC, COMBINEFUNC, etc.). Test with minimal aggregates and complex aggregates with all optional clauses.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update serialize() signature and add format check",
            "description": "Modify the CreateAggregate.serialize() method to accept SerializeOptions parameter and add conditional logic to check if formatting is enabled",
            "dependencies": [],
            "details": "In src/core/objects/aggregate/changes/aggregate.create.ts:\n- Import SqlFormatter and SqlFormatOptions from the core/format module (once available from parent task dependencies)\n- Import SerializeOptions type from core/integrations/serialize\n- Change serialize() signature from serialize(): string to serialize(options?: SerializeOptions): string\n- Add conditional check: if (!options?.format?.enabled) return existing compact serialization\n- If format is enabled, instantiate SqlFormatter with options.format and call serializeFormatted(formatter)\n- Keep existing serialization logic (lines 170-292) as the default/fallback path",
            "status": "pending",
            "testStrategy": "No new tests needed - existing tests continue to pass with compact format. Formatted tests added in subtask 4."
          },
          {
            "id": 2,
            "title": "Implement serializeFormatted() with keyword formatting",
            "description": "Create private serializeFormatted() method that formats the CREATE AGGREGATE head clause with proper keyword casing",
            "dependencies": [
              1
            ],
            "details": "In src/core/objects/aggregate/changes/aggregate.create.ts:\n- Create private serializeFormatted(formatter: SqlFormatter): string method\n- Format head clause components using formatter.keyword():\n  * CREATE keyword\n  * OR REPLACE keywords (if this.orReplace is true)\n  * AGGREGATE keyword\n  * Qualified name and signature (not keywords, use as-is)\n- Build head string by joining formatted keywords with spaces\n- Return head + formatted body (body implementation in next subtask)\n- Follow pattern from other objects that implement formatted serialization",
            "status": "pending",
            "testStrategy": "Manual testing with formatter.keyword() to verify correct keyword casing (uppercase/lowercase based on format options)"
          },
          {
            "id": 3,
            "title": "Format aggregate clauses with indentation and newlines",
            "description": "Implement clause formatting with each clause on a separate line using proper indentation instead of comma-separated inline format",
            "dependencies": [
              2
            ],
            "details": "In the serializeFormatted() method:\n- Reuse existing clauses array building logic (lines 181-288) that handles all optional clauses: SFUNC, STYPE, SSPACE, FINALFUNC, FINALFUNC_EXTRA, FINALFUNC_MODIFY, COMBINEFUNC, SERIALFUNC, DESERIALFUNC, INITCOND, MSFUNC, MINVFUNC, MSTYPE, MSSPACE, MFINALFUNC, MFINALFUNC_EXTRA, MFINALFUNC_MODIFY, MINITCOND, SORTOP, PARALLEL, STRICT, HYPOTHETICAL\n- Apply formatter.keyword() to all clause keywords (SFUNC, STYPE, etc.)\n- Apply formatter.indent(1) to each clause for proper indentation\n- Join clauses with newlines (\\n) instead of ', '\n- Wrap in parentheses using formatter.parens(clauses.join('\\n'), multiline=true)\n- Return formatted head + formatted body",
            "status": "pending",
            "testStrategy": "Manual inspection of output with various indent widths and keyword casing options to verify proper multi-line formatting"
          },
          {
            "id": 4,
            "title": "Add unit tests for formatted aggregate output",
            "description": "Add comprehensive test cases in aggregate.create.test.ts to verify formatted serialization works correctly for minimal and complex aggregates",
            "dependencies": [
              3
            ],
            "details": "In src/core/objects/aggregate/changes/aggregate.create.test.ts:\n- Add test case 'serialize minimal aggregate with formatting' that:\n  * Creates aggregate with only required clauses (SFUNC, STYPE)\n  * Calls serialize({ format: { enabled: true } })\n  * Asserts output has CREATE AGGREGATE on first line, clauses on separate indented lines\n- Add test case 'serialize complex aggregate with formatting' that:\n  * Creates aggregate with many optional clauses (from existing test at lines 68-100)\n  * Calls serialize({ format: { enabled: true } }) with orReplace: true\n  * Asserts multi-line formatted output with all clauses properly indented\n- Test different format options: keyword casing (upper/lower), indent widths (2, 4 spaces)\n- Verify existing tests still pass (backward compatibility with compact format)",
            "status": "pending",
            "testStrategy": "Run npm test or vitest to verify all test cases pass and formatted output matches expected multi-line structure"
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement CREATE POLICY Formatting",
        "description": "Add formatted output support to CreateRlsPolicy with clauses on separate lines",
        "details": "Update src/core/objects/rls-policy/changes/rls-policy.create.ts:\n- Import SqlFormatter and SqlFormatOptions from core/format\n- Update serialize(options?: SerializeOptions) signature\n- Check if options?.format?.enabled is true\n- If disabled, use existing compact serialization\n- If enabled, create private serializeFormatted(formatter: SqlFormatter) method:\n  * Line 1: CREATE POLICY name ON schema.table\n  * Subsequent lines (not indented, same level as CREATE):\n    - AS RESTRICTIVE (if applicable)\n    - FOR command (if not default)\n    - TO roles (if not default)\n    - USING (expression)\n    - WITH CHECK (expression)\n  * Use formatter.keyword() for all SQL keywords\n  * Join lines with '\\n'\n- Add unit tests for formatted output",
        "testStrategy": "Unit tests verify formatted policy output with AS, FOR, TO, USING, WITH CHECK clauses. Test permissive/restrictive, all commands, various role lists, with/without USING and WITH CHECK expressions.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update serialize() method signature and add format check",
            "description": "Modify the serialize() method to accept SerializeOptions parameter and check if formatting is enabled",
            "dependencies": [],
            "details": "Import SqlFormatter and SqlFormatOptions from core/format module. Update the serialize() method signature from serialize(): string to serialize(options?: SerializeOptions): string. Add conditional logic to check if options?.format?.enabled is true. If formatting is disabled or undefined, return the existing compact serialization (current implementation). If enabled, call the serializeFormatted() method (to be implemented in next subtask) passing a new SqlFormatter instance created from options.format.",
            "status": "pending",
            "testStrategy": "Unit tests verify that serialize() without options or with format.enabled=false returns the existing compact output. Tests verify that serialize() with format.enabled=true calls serializeFormatted() and returns formatted output."
          },
          {
            "id": 2,
            "title": "Implement serializeFormatted() method for multiline policy output",
            "description": "Create private serializeFormatted() method that formats CREATE POLICY with clauses on separate lines at the same indentation level",
            "dependencies": [
              1
            ],
            "details": "Create private serializeFormatted(formatter: SqlFormatter): string method. Line 1: Use formatter.keyword() for CREATE POLICY, add policy name, formatter.keyword('ON'), and schema.table. Subsequent lines (not indented, same level as CREATE): Add formatter.keyword('AS RESTRICTIVE') if !permissive. Add formatter.keyword('FOR') + command if not default (*). Add formatter.keyword('TO') + roles.join(', ') if not default public. Add formatter.keyword('USING') + (expression) if using_expression exists. Add formatter.keyword('WITH CHECK') + (expression) if with_check_expression exists. Join all lines with '\\n' and return the result.",
            "status": "pending",
            "testStrategy": "Unit tests verify formatted output structure: first line contains CREATE POLICY name ON table, subsequent clauses each on their own line. Test permissive vs restrictive policies. Test all FOR command variants (SELECT, INSERT, UPDATE, DELETE, ALL). Test various role lists. Test policies with and without USING/WITH CHECK expressions."
          },
          {
            "id": 3,
            "title": "Add comprehensive unit tests for formatted policy output",
            "description": "Create unit tests covering all CREATE POLICY clause combinations and formatting options",
            "dependencies": [
              2
            ],
            "details": "Add test cases in rls-policy.create.test.ts (or create if doesn't exist) for formatted output. Test permissive policy with all default values (minimal output). Test restrictive policy (AS RESTRICTIVE clause). Test all FOR commands: SELECT, INSERT, UPDATE, DELETE, ALL. Test TO clause with single role, multiple roles, and default PUBLIC. Test policies with USING clause only, WITH CHECK clause only, and both clauses. Test keyword case options (upper, lower, preserve). Test that expressions in USING and WITH CHECK are wrapped in parentheses correctly. Verify line breaks appear between all clauses.",
            "status": "pending",
            "testStrategy": "Each test creates a CreateRlsPolicy instance with specific options, calls serialize() with format.enabled=true, and asserts the output matches expected formatted SQL. Tests verify keyword casing, clause ordering, line breaks, and proper handling of optional clauses."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement CREATE VIEW and CREATE MATERIALIZED VIEW Formatting",
        "description": "Add formatted output support to CreateView and CreateMaterializedView with AS on separate line",
        "details": "Update src/core/objects/view/changes/view.create.ts:\n- Import SqlFormatter and SqlFormatOptions from core/format\n- Update serialize(options?: SerializeOptions) signature\n- Check if options?.format?.enabled is true\n- If disabled, use existing compact serialization\n- If enabled, create private serializeFormatted(formatter: SqlFormatter) method:\n  * Line 1: CREATE [OR REPLACE] VIEW schema.name\n  * Line 2 (if options): WITH (options)\n  * Line 3: AS\n  * Line 4+: Indented query body (formatter.indent(1) + definition.trim())\n  * Use formatter.keyword() for all SQL keywords\n\nUpdate src/core/objects/materialized-view/changes/materialized-view.create.ts:\n- Same approach as view\n- Additional clauses: TABLESPACE\n- Format: CREATE MATERIALIZED VIEW name, [WITH options], [TABLESPACE x], AS, indented query\n- Add unit tests for both",
        "testStrategy": "Unit tests verify formatted view and materialized view output. Test with/without options, with/without TABLESPACE. Verify query body is indented correctly and AS keyword is on its own line.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update CreateView serialize() to support formatted output",
            "description": "Modify CreateView class to check format options and implement formatted serialization with AS keyword on separate line",
            "dependencies": [],
            "details": "In src/core/objects/view/changes/view.create.ts:\n1. Import SqlFormatter and SqlFormatOptions from core/format (once Task 1 and 2 are complete in parent)\n2. Update serialize() method signature to accept options?: SerializeOptions parameter\n3. Add format check: if (!options?.format?.enabled) return existing compact serialization\n4. Create private serializeFormatted(formatter: SqlFormatter) method that formats:\n   - Line 1: CREATE [OR REPLACE] VIEW schema.name\n   - Line 2 (if options exist): WITH (options)\n   - Line 3: AS\n   - Line 4+: Indented query body using formatter.indent(1) + definition.trim()\n5. Use formatter.keyword() for CREATE, OR REPLACE, VIEW, WITH, AS keywords\n6. Return formatted result when enabled",
            "status": "pending",
            "testStrategy": "Add unit tests in view.create.test.ts to verify formatted output matches expected format with AS on separate line, proper indentation of query body, keyword casing applied correctly, and WITH options formatted properly when present"
          },
          {
            "id": 2,
            "title": "Update CreateMaterializedView serialize() to support formatted output",
            "description": "Modify CreateMaterializedView class to check format options and implement formatted serialization with AS keyword on separate line and TABLESPACE support",
            "dependencies": [],
            "details": "In src/core/objects/materialized-view/changes/materialized-view.create.ts:\n1. Import SqlFormatter and SqlFormatOptions from core/format (once Task 1 and 2 are complete in parent)\n2. Update serialize() method signature to accept options?: SerializeOptions parameter\n3. Add format check: if (!options?.format?.enabled) return existing compact serialization\n4. Create private serializeFormatted(formatter: SqlFormatter) method that formats:\n   - Line 1: CREATE MATERIALIZED VIEW schema.name\n   - Line 2 (if options exist): WITH (options)\n   - Line 3 (if tablespace exists): TABLESPACE tablespace_name (note: currently not modeled per comment on line 23)\n   - Line N: AS\n   - Line N+1+: Indented query body using formatter.indent(1) + definition.trim()\n   - Final line: WITH [NO] DATA based on is_populated flag\n5. Use formatter.keyword() for all SQL keywords\n6. Return formatted result when enabled",
            "status": "pending",
            "testStrategy": "Add unit tests in materialized-view.create.test.ts to verify formatted output with AS on separate line, proper indentation of query body, WITH [NO] DATA clause formatted correctly, keyword casing applied, and WITH options formatted properly when present"
          },
          {
            "id": 3,
            "title": "Implement query body indentation for view definitions",
            "description": "Ensure query definitions in both CreateView and CreateMaterializedView are properly indented when formatted",
            "dependencies": [
              1,
              2
            ],
            "details": "In both view.create.ts and materialized-view.create.ts:\n1. Use formatter.indent(1) to create one level of indentation\n2. Apply indentation to the beginning of the query body: formatter.indent(1) + definition.trim()\n3. Handle multi-line query definitions by ensuring each line maintains proper indentation\n4. The definition.trim() removes any leading/trailing whitespace from the original query\n5. Verify that the query body starts on the line immediately after the AS keyword\n6. Consider whether multi-line queries need each line indented (may require splitting definition by newlines and indenting each line)",
            "status": "pending",
            "testStrategy": "Test with simple single-line SELECT queries and complex multi-line queries. Verify indentation is consistent across all lines of the query body. Test with various indentWidth settings (2, 4, 8 spaces). Ensure query body formatting doesn't break SQL syntax."
          },
          {
            "id": 4,
            "title": "Add comprehensive unit tests for view formatting",
            "description": "Create unit tests for both CreateView and CreateMaterializedView formatted serialization covering all configuration options and edge cases",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create or update test files:\n1. In view.create.test.ts, add test cases for:\n   - Basic view with format enabled vs disabled\n   - View with OR REPLACE clause\n   - View with WITH options\n   - Various keyword case settings (upper, lower, preserve)\n   - Different indent widths (2, 4, 8)\n   - Single-line and multi-line query definitions\n2. In materialized-view.create.test.ts, add test cases for:\n   - Basic materialized view with format enabled vs disabled\n   - Materialized view with WITH options\n   - Materialized view with WITH DATA and WITH NO DATA\n   - Various keyword case settings\n   - Different indent widths\n   - Single-line and multi-line query definitions\n3. Test that format disabled returns original compact serialization\n4. Verify AS keyword appears on its own line in formatted output",
            "status": "pending",
            "testStrategy": "Run npm test to execute all unit tests. Verify all test cases pass. Check test coverage for view.create.ts and materialized-view.create.ts to ensure serialize methods are fully covered. Tests should use snapshot testing or exact string matching to verify formatted output."
          }
        ]
      },
      {
        "id": 10,
        "title": "Add CLI Flags for SQL Formatting",
        "description": "Add --format-sql and related flags to plan and sync commands",
        "details": "Update src/cli/commands/plan.ts:\n- Add flags in parameters.flags:\n  * formatSql: boolean (kind: 'boolean', brief: 'Enable SQL formatting', optional: true)\n  * keywordCase: enum ('preserve'|'upper'|'lower', brief: 'Keyword case transformation', optional: true)\n  * lineWidth: number (kind: 'parsed', parse: Number, brief: 'Maximum line width', optional: true)\n  * indentWidth: number (kind: 'parsed', parse: Number, brief: 'Spaces per indentation level', optional: true)\n  * commaStyle: enum ('trailing'|'leading', brief: 'Comma placement style', optional: true)\n  * alignColumns: boolean (kind: 'boolean', brief: 'Align column definitions in CREATE TABLE', optional: true)\n- Construct SqlFormatOptions from flags\n- Pass format options to createPlan() via CreatePlanOptions\n- Update help text to document all flags\n\nUpdate src/cli/commands/sync.ts:\n- Same flags as plan command\n- Pass format options through to createPlan()\n\nUpdate docs/cli.md with examples of formatting flags",
        "testStrategy": "Integration tests verify CLI flags are parsed correctly and passed through to plan creation. Test with various flag combinations including alignColumns and verify formatted SQL output with column alignment.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add SQL formatting flags to plan.ts command",
            "description": "Add formatSql, keywordCase, lineWidth, indentWidth, commaStyle, and alignColumns flags to plan.ts following existing flag patterns",
            "dependencies": [],
            "details": "Update src/cli/commands/plan.ts parameters.flags section (lines 17-84):\n- Add formatSql: { kind: 'boolean', brief: 'Enable SQL formatting', optional: true }\n- Add keywordCase: { kind: 'enum', brief: 'Keyword case transformation', values: ['preserve', 'upper', 'lower'], optional: true }\n- Add lineWidth: { kind: 'parsed', parse: Number, brief: 'Maximum line width', optional: true }\n- Add indentWidth: { kind: 'parsed', parse: Number, brief: 'Spaces per indentation level', optional: true }\n- Add commaStyle: { kind: 'enum', brief: 'Comma placement style', values: ['trailing', 'leading'], optional: true }\n- Add alignColumns: { kind: 'boolean', brief: 'Align column definitions in CREATE TABLE', optional: true }\n\nFollow the existing pattern seen with filter/serialize flags (lines 48-77). Update the flags parameter type in the func signature to include these new optional properties.",
            "status": "pending",
            "testStrategy": "Unit tests verify flag parsing with various combinations. Test invalid values for enums and numbers are rejected. Test that flags are optional and can be omitted."
          },
          {
            "id": 2,
            "title": "Construct SqlFormatOptions and pass to createPlan in plan.ts",
            "description": "Build SqlFormatOptions object from parsed flags and pass through CreatePlanOptions format property to createPlan()",
            "dependencies": [
              1
            ],
            "details": "Update src/cli/commands/plan.ts func implementation (around line 124):\n- Import SqlFormatOptions from '../../core/format/index.ts'\n- After loading integration DSL (line 122), construct format options:\n  * If formatSql is true or any format flag is present, create SqlFormatOptions object\n  * Map flags to SqlFormatOptions properties: { enabled: flags.formatSql ?? true, keywordCase: flags.keywordCase, lineWidth: flags.lineWidth, indentWidth: flags.indentWidth, commaStyle: flags.commaStyle, alignColumns: flags.alignColumns }\n  * Only include properties that are defined\n- Pass format options to createPlan() call via CreatePlanOptions.format property\n- Format options should be undefined if no formatting flags provided",
            "status": "pending",
            "testStrategy": "Integration tests verify SqlFormatOptions are correctly constructed from various flag combinations and passed to createPlan(). Test that formatted SQL output appears when flags are used."
          },
          {
            "id": 3,
            "title": "Add SQL formatting flags to sync.ts command",
            "description": "Add the same formatSql, keywordCase, lineWidth, indentWidth, commaStyle, alignColumns flags to sync.ts and pass to createPlan()",
            "dependencies": [
              1
            ],
            "details": "Update src/cli/commands/sync.ts:\n- Add identical flag definitions as plan.ts to parameters.flags (lines 22-86)\n- Import SqlFormatOptions from '../../core/format/index.ts'\n- Update flags parameter type in func signature to include formatting flags\n- Construct SqlFormatOptions from flags using same logic as plan.ts\n- Pass format options to createPlan() call at line 135 via CreatePlanOptions.format property\n\nEnsure consistency with plan.ts implementation. Both commands should handle formatting flags identically.",
            "status": "pending",
            "testStrategy": "Integration tests verify sync command accepts formatting flags and passes them through. Test formatted output in sync preview before confirmation prompt."
          },
          {
            "id": 4,
            "title": "Add CLI integration tests for formatting flags",
            "description": "Create integration tests that verify CLI flags are parsed correctly and produce formatted SQL output",
            "dependencies": [
              2,
              3
            ],
            "details": "Create or update test file for CLI command integration tests:\n- Test plan command with --format-sql flag produces formatted output\n- Test plan command with --keyword-case=upper produces uppercase keywords\n- Test plan command with --comma-style=leading produces leading commas\n- Test plan command with --line-width and --indent-width affect formatting\n- Test sync command with same formatting flag combinations\n- Test that flags are optional and defaults work correctly\n- Test invalid enum values are rejected with clear error messages\n- Test flag combinations work together (e.g., --format-sql --keyword-case=upper --indent-width=4)\n\nTests should invoke actual CLI commands with test databases and verify output format.",
            "status": "pending",
            "testStrategy": "End-to-end CLI tests using actual command invocation with temporary test databases. Verify SQL output matches expected formatting based on flags provided. Test both plan and sync commands."
          }
        ]
      },
      {
        "id": 11,
        "title": "Integration Tests for Formatted SQL Output",
        "description": "Create end-to-end tests verifying formatted SQL is valid and executes successfully",
        "details": "Create tests/integration/format.integration.test.ts (or add to existing integration test file):\n- Test plan generation with formatting enabled (formatSql: true)\n- Verify formatted SQL is syntactically valid\n- Execute formatted SQL against PostgreSQL test instance using testcontainers\n- Test various option combinations:\n  * keywordCase: upper/lower/preserve\n  * commaStyle: trailing/leading\n  * indentWidth: 2/4\n- Verify plan JSON correctly stores format options\n- Test applying plan with format options preserved\n- Verify formatted vs unformatted SQL produces identical database state\n- Test all statement types: CREATE TABLE, CREATE TYPE (enum/composite), CREATE AGGREGATE, CREATE POLICY, CREATE VIEW, CREATE MATERIALIZED VIEW",
        "testStrategy": "Integration tests using Vitest + testcontainers. Create test databases with various schemas, generate plans with formatting, execute SQL, verify database state matches expected. Compare formatted and unformatted outputs produce identical results.",
        "priority": "medium",
        "dependencies": [
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up integration test file with testcontainers",
            "description": "Create tests/integration/format.integration.test.ts following existing patterns in tests/integration/ directory with testcontainers PostgreSQL setup",
            "dependencies": [],
            "details": "Create new test file tests/integration/format.integration.test.ts. Follow patterns from existing integration tests using globalSetup configured in vitest.config.ts lines 26-39. Set up testcontainers PostgreSQL instance for test execution. Create helper functions for: (1) executing SQL statements, (2) comparing database states, (3) generating plans with format options, (4) applying plans. Import necessary dependencies from @testcontainers/postgresql, vitest, and project modules. Set up beforeAll/afterAll hooks for container lifecycle management.",
            "status": "pending",
            "testStrategy": "Verify test file structure is created correctly, testcontainers initializes successfully, and helper functions are accessible. Run basic smoke test to ensure PostgreSQL container starts and accepts connections."
          },
          {
            "id": 2,
            "title": "Create test cases for CREATE TABLE formatting with all variants",
            "description": "Implement comprehensive test cases for CREATE TABLE statements including regular, partitioned, inherited, and partition child tables with formatted output",
            "dependencies": [
              1
            ],
            "details": "Create test suite for CREATE TABLE formatting covering: (1) Regular tables with multiple columns and constraints, (2) Partitioned tables (PARTITION BY RANGE/LIST/HASH), (3) Partition child tables (PARTITION OF), (4) Inherited tables (INHERITS), (5) Tables with storage parameters (WITH clause). For each variant, test with formatSql: true and verify: SQL is syntactically valid, executes successfully against PostgreSQL, produces identical database state as unformatted SQL. Create database fixtures with sample schemas. Test column definitions, constraints, indexes formatting.",
            "status": "pending",
            "testStrategy": "Execute formatted and unformatted SQL for each table variant. Query pg_catalog to verify table structure matches expected. Compare column definitions, constraints, partitioning configuration, inheritance hierarchy, and storage parameters between formatted and unformatted executions."
          },
          {
            "id": 3,
            "title": "Create test cases for CREATE TYPE (enum and composite)",
            "description": "Implement test cases for CREATE TYPE statements covering both ENUM and COMPOSITE types with formatted output validation",
            "dependencies": [
              1
            ],
            "details": "Create test suite for CREATE TYPE formatting covering: (1) ENUM types with multiple values on separate lines, (2) COMPOSITE types with multiple attributes including data types and collations, (3) Edge cases: empty enums, single value enums, enums with special characters in labels, composite types with complex data types (arrays, custom types). Test format options: keywordCase (upper/lower/preserve), commaStyle (trailing/leading), indentWidth (2/4). Verify formatted SQL executes successfully and creates identical types as unformatted SQL. Query pg_type and pg_attribute to validate type definitions.",
            "status": "pending",
            "testStrategy": "Execute formatted and unformatted CREATE TYPE statements. Query pg_catalog.pg_type to verify type exists with correct typtype (e for enum, c for composite). For enums, query pg_enum to verify all labels match. For composite types, query pg_attribute to verify all attributes with correct data types and collations."
          },
          {
            "id": 4,
            "title": "Create test cases for CREATE AGGREGATE, POLICY, VIEW, MATERIALIZED VIEW",
            "description": "Implement test cases for CREATE AGGREGATE, CREATE POLICY, CREATE VIEW, and CREATE MATERIALIZED VIEW statements with formatted output",
            "dependencies": [
              1
            ],
            "details": "Create test suites for remaining statement types: (1) CREATE AGGREGATE: test with SFUNC, STYPE, FINALFUNC, COMBINEFUNC, INITCOND and other clauses on separate lines, (2) CREATE POLICY: test row-level security policies with USING and WITH CHECK expressions, (3) CREATE VIEW: test views with complex SELECT statements, JOINs, WHERE clauses, (4) CREATE MATERIALIZED VIEW: test with WITH DATA/NO DATA, storage parameters. For each type, verify formatted SQL is syntactically valid and produces identical database objects. Test with various complexity levels from simple to complex definitions.",
            "status": "pending",
            "testStrategy": "Execute formatted and unformatted statements for each object type. For aggregates, query pg_aggregate and pg_proc to verify function configuration. For policies, query pg_policy to verify policy definitions. For views, query pg_views and verify view definitions match. For materialized views, query pg_matviews and verify definitions and data population."
          },
          {
            "id": 5,
            "title": "Test all format option combinations for each statement type",
            "description": "Create comprehensive tests covering all format option combinations (keywordCase  commaStyle  indentWidth) for each statement type",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "For each statement type (TABLE, ENUM, COMPOSITE, AGGREGATE, POLICY, VIEW, MATERIALIZED VIEW), create test matrix covering: keywordCase options (upper, lower, preserve)  commaStyle options (trailing, leading)  indentWidth options (2, 4) = 12 combinations per statement type. Use parameterized tests (test.each or describe.each) to avoid duplication. For each combination: (1) Generate plan with specific format options, (2) Verify plan JSON correctly stores format options, (3) Execute formatted SQL, (4) Verify SQL is syntactically valid and executes successfully. Focus on ensuring format variations don't break SQL validity.",
            "status": "pending",
            "testStrategy": "Use Vitest's test.each() to parameterize format option combinations. For each combination, verify: (1) SQL executes without syntax errors, (2) Plan JSON serialization preserves exact format options, (3) Applying plan with stored format options reproduces same formatted output. Sample a subset of complex schemas across all option combinations to ensure comprehensive coverage without excessive test runtime."
          },
          {
            "id": 6,
            "title": "Verify formatted vs unformatted SQL produces identical database state",
            "description": "Create comprehensive validation tests confirming formatted and unformatted SQL generate identical database schemas and object definitions",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "For each statement type, create tests that: (1) Execute unformatted SQL and capture resulting database state, (2) Execute formatted SQL (with various format options) and capture resulting database state, (3) Compare database states using deep equality checks on pg_catalog queries. Comparison should validate: table structures (columns, types, constraints, indexes), type definitions (enum values, composite attributes), aggregate function definitions (state type, transition function, etc.), policies (expressions, roles), view definitions (query equivalence), materialized view definitions and data. Create helper function to introspect and serialize database state for comparison. Test with complex schemas involving multiple interdependent objects.",
            "status": "pending",
            "testStrategy": "Execute both formatted and unformatted SQL to create parallel database schemas. Query pg_catalog system tables to extract complete schema definitions. Serialize and compare: pg_class, pg_attribute, pg_constraint, pg_index, pg_type, pg_enum, pg_aggregate, pg_policy, pg_views, pg_matviews. Use JSON serialization for deep equality comparison. Ensure formatting changes only affect whitespace/case, not semantic meaning or execution results."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2026-02-02T18:45:52.411Z",
      "updated": "2026-02-02T18:45:52.411Z",
      "description": "Tasks for master context"
    }
  }
}