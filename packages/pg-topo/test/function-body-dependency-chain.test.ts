import { describe, expect, test } from "bun:test";
import { analyzeAndSort } from "../src/analyze-and-sort";
import { validateAnalyzeResultWithPostgres } from "./support/postgres-validation";

const complexFunctionChainStatements = [
  `
create view app.project_exports as
select
    p.id,
    app.project_export_row(p.id) as export_key
from app.projects p;
`,
  `
create function app.project_export_row(project_id bigint) returns text
    language plpgsql
as $$
declare
    slug text;
    organization_slug text;
begin
    select
        app.project_slug(project_id),
        o.slug
    into
        slug,
        organization_slug
    from app.projects p
    join app.organizations o on o.id = p.organization_id
    where p.id = project_id;

    return app.slugify(organization_slug || '-' || slug);
end;
$$;
`,
  `
create function app.project_slug(project_id bigint) returns text
    language sql
    stable
as $$
    select app.slugify(app.project_owner_label(project_id) || '-' || p.name)
    from app.projects p
    where p.id = project_id;
$$;
`,
  `
create function app.project_owner_label(project_id bigint) returns text
    language sql
    stable
as $$
    select app.slugify(app.user_display_name(p.owner_id))
    from app.projects p
    where p.id = project_id;
$$;
`,
  `
create function app.user_display_name(user_id bigint) returns text
    language sql
    stable
as $$
    select lower(u.email)
    from app.users u
    where u.id = user_id;
$$;
`,
  `
create function app.slugify(input text) returns text
    language sql
    immutable
as $$
    select lower(regexp_replace(input, '[^a-zA-Z0-9-]+', '-', 'g'));
$$;
`,
  `
create table app.projects (
    id bigint generated by default as identity primary key,
    organization_id bigint not null references app.organizations(id),
    owner_id bigint not null references app.users(id),
    name text not null
);
`,
  `
create table app.users (
    id bigint generated by default as identity primary key,
    organization_id bigint not null references app.organizations(id),
    email text not null
);
`,
  `
create table app.organizations (
    id bigint generated by default as identity primary key,
    slug text not null
);
`,
  `
create schema app;
`,
];

const seededRandom = (seed: number): (() => number) => {
  let state = seed >>> 0;
  return () => {
    state = (state * 1664525 + 1013904223) >>> 0;
    return state / 4294967296;
  };
};

const shuffleDeterministic = <T>(items: T[], seed: number): T[] => {
  const random = seededRandom(seed);
  const cloned = [...items];
  for (let index = cloned.length - 1; index > 0; index -= 1) {
    const randomIndex = Math.floor(random() * (index + 1));
    const current = cloned[index];
    cloned[index] = cloned[randomIndex] as T;
    cloned[randomIndex] = current as T;
  }
  return cloned;
};

describe("function body dependency chains", () => {
  test("randomized function/table dependency chains still execute at runtime", async () => {
    const shuffled = shuffleDeterministic(complexFunctionChainStatements, 47);
    const result = await analyzeAndSort(shuffled);
    const validation = await validateAnalyzeResultWithPostgres(result);
    const executionErrors = validation.diagnostics.filter(
      (diagnostic) => diagnostic.code === "RUNTIME_EXECUTION_ERROR",
    );

    expect(executionErrors).toHaveLength(0);
  }, 120000);
});
